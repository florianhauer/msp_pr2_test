
#ifndef MSP_H_
#define MSP_H_

#include <deque>
#include <map>
#include <vector>
#include <utility>
#include <string>
#include "Graph.h"
#include "Tree.h"
#include "State.h"

template <unsigned int DIM> class MSP{
public:
	MSP(Tree<DIM>* tree);
	bool init(State<DIM> start,State<DIM> end);
	bool step();
	bool run();
	std::deque<State<DIM>> getPath(){return m_current_path;}
	std::deque<State<DIM>> getSmoothedPath();
	double getPathCost(){return std::accumulate(m_path_cost.begin(),m_path_cost.end(),0.0);}
	void setAlpha(double a){m_alpha=a;}
	void setSpeedUp(bool a){m_speed_up=a;}
	bool isEpsilonObstacle(Node<DIM>* n);

protected:
	void iterationDetails(kshortestpaths::BasePath* result=NULL);
	bool inPath(State<DIM> pt,double size);
	void reducedGraph();
	bool neighboor(std::pair<State<DIM>,double> &na,std::pair<State<DIM>,double> &nb);
	bool is_start(std::pair<State<DIM>,double> &node){return is_in(m_current_coord,node);}
	bool is_goal(std::pair<State<DIM>,double> &node){return is_in(m_end_coord,node);}
	bool is_in(State<DIM> pt,std::pair<State<DIM>,double> node);
	double cost(Node<DIM>* n);
	void add_node_to_reduced_vertices(Node<DIM>* node,State<DIM> coord, double size);
	State<DIM> m_start_coord;
	State<DIM> m_end_coord;
	State<DIM> m_oStart_coord;
	State<DIM> m_oEnd_coord;
	State<DIM> m_current_coord;
	double m_current_scale;
	Tree<DIM>* m_tree;
	int m_start_index;
	int m_nb_backtrack;
	int m_end_index;
	bool m_speed_up;
	bool m_path_found;
	std::deque<State<DIM>> m_current_path;
	kshortestpaths::Graph m_graph;
	std::map<State<DIM>,std::set<State<DIM>>> m_misleading;
	std::set<State<DIM>> m_current_forbidden;
	double m_alpha;//used in reduced graph as parameter for decomposition
	std::vector<std::pair<State<DIM>,double> > m_nodes; //coord,size
	std::vector<double> m_cost;
	std::vector<double> m_path_cost;
	double m_epsilon;
	double m_M;
	double m_lambda1;
	double m_lambda2;
	int m_nb_step;
};




#include "MSP.h"
#include "DijkstraShortestPathAlg.h"
#include "YenTopKShortestPathsAlg.h"
#include <set>
#include <cmath>
#include <numeric>
#include <sstream>
#include <fstream>
#include <stdexcept>
#include <algorithm>


template <unsigned int DIM> MSP<DIM>::MSP(Tree<DIM>* tree):m_tree(tree) {
	m_M=100*pow(2,DIM*tree->getMaxDepth());
	m_epsilon=0.5;
	m_current_scale=0;
	m_end_index=0;
	m_nb_backtrack=0;
	m_nb_step=0;
	m_start_index=0;
	m_speed_up=true;
	m_path_found=false;
	m_alpha=0.55*sqrt(DIM);
	m_lambda1=0.999;
	m_lambda2=0.001;
}

template <unsigned int DIM> bool MSP<DIM>::isEpsilonObstacle(Node<DIM>* n){
	if(n->getValue()>1-m_epsilon/m_tree->getVolume(n->getDepth()))
		return true;
	return false;
}


template <unsigned int DIM> bool MSP<DIM>::init(State<DIM> start,State<DIM> end){
	m_oStart_coord=start;
	m_oEnd_coord=end;
	State<DIM> startc;
	State<DIM> goalc;
	Node<DIM>* nstart=m_tree->getNode(start,startc);
	Node<DIM>* ngoal=m_tree->getNode(end,goalc);
	if(nstart->isLeaf() && ngoal->isLeaf() && !isEpsilonObstacle(nstart) && !isEpsilonObstacle(ngoal)){
		m_current_coord=startc;
		m_current_scale=m_tree->getScale(nstart->getDepth());
		m_start_coord=startc;
		m_end_coord=goalc;
		m_current_path.clear();
		m_path_cost.clear();
		m_current_path.push_back(m_start_coord);
		m_misleading.clear();
		m_misleading[m_current_coord]=std::set<State<DIM>>();
		m_nb_step=0;
		m_nb_backtrack=0;
		return true;
	}else{
		std::cout << "start "<< startc << " or goal "<< goalc << " not leaf on free space" << std::endl;
		if(isEpsilonObstacle(nstart))
			std::cout << "start not on free space: " << startc << std::endl;
		if(isEpsilonObstacle(ngoal))
			std::cout << "goal not on free space" << goalc << std::endl;
		return false;
	}
	return false;
}

template <unsigned int DIM> bool MSP<DIM>::step(){
	reducedGraph();
	kshortestpaths::YenTopKShortestPathsAlg yenAlg(m_graph, m_graph.get_vertex(m_start_index),m_graph.get_vertex(m_end_index));
	//if solution
	if(yenAlg.has_next()){
		//go forward // if goal return false;
		kshortestpaths::BasePath* result =yenAlg.next();
		iterationDetails(result);
		int next_point_id=result->GetVertex(1)->getID();
		//do stuff to prepare next iteration
		m_misleading[m_current_coord].insert(m_nodes[next_point_id].first);
		m_current_path.push_back(m_nodes[next_point_id].first);
		m_path_cost.push_back(m_cost[next_point_id]);

		if(m_speed_up){
			int mv_fwd=2;
			while(result->length()>mv_fwd){
				int next_point_id2=result->GetVertex(mv_fwd)->getID();
				if(m_tree->getNode(m_nodes[next_point_id2].first)->isLeaf()){
					m_misleading[m_nodes[next_point_id].first].insert(m_nodes[next_point_id2].first);
					m_current_path.push_back(m_nodes[next_point_id2].first);
					m_path_cost.push_back(m_cost[next_point_id2]);
					next_point_id=next_point_id2;
					++mv_fwd;
				}else{
					break;
				}
			}
		}

		m_current_coord=m_nodes[next_point_id].first;
		m_current_scale=m_nodes[next_point_id].second;

		if(next_point_id==m_end_index){
			std::cout << "goal reached" << std::endl;
			m_path_found=true;
			return false;
		}else{
			return true;
		}

	}else{
		iterationDetails();
		m_misleading[m_current_coord].clear();
		m_nb_backtrack++;
		m_current_path.pop_back();
		if(m_current_path.size()==0){
			//no possible path
			return false;
		}else{
			m_current_coord=m_current_path.back();
			m_current_scale=m_tree->getScale(m_tree->getNode(m_current_coord)->getDepth());
			m_path_cost.pop_back();
			return true;
		}
	}
}

template <unsigned int DIM> bool MSP<DIM>::run(){
	while(step()){/*std::cout<<*/++m_nb_step;}
	std::cout<< "NB backtrack : " << m_nb_backtrack << std::endl;
	if(m_path_found){
		m_current_path.push_front(m_oStart_coord);
		m_current_path.push_back(m_oEnd_coord);
		return true;
	}else{
		return false;
	}
}

template <unsigned int DIM> bool MSP<DIM>::inPath(State<DIM> pt,double scale){
	return std::any_of(m_current_path.begin(),m_current_path.end(),
			[pt,scale,this](State<DIM> it){return this->is_in(it,std::pair<State<DIM>,double>(pt,scale)) && (it-m_current_path.back()).normSq()!=0;});
}

template <unsigned int DIM> void MSP<DIM>::add_node_to_reduced_vertices(Node<DIM>* node,State<DIM> coord, double scale){
//	std::cout << coord << " , " << scale << " , " << node->getValue() << " , " << node->isEpsilonObstacle() << " , " << inPath(coord,scale) << " , " << (m_current_forbidden.find(coord)==m_current_forbidden.end()) << std::endl;
	if(((coord-m_current_coord).norm()-0.5*sqrt(DIM)*m_current_scale*4*((*(m_tree->getDirections()))[0].max())>m_alpha*scale*4*((*(m_tree->getDirections()))[0].max()) || node->isLeaf())
			&& !inPath(coord,scale)
			&& !isEpsilonObstacle(node)
			&& m_current_forbidden.find(coord)==m_current_forbidden.end()
	){
		m_nodes.push_back(std::pair<State<DIM>,double>(coord,scale));
		m_cost.push_back(cost(node));
	}else{
		if(!node->isLeaf()){
			for(int i=0;i<TwoPow<DIM>::value;++i){
				add_node_to_reduced_vertices(node->getChild(i),coord+(*(m_tree->getDirections()))[i]*scale,scale*0.5);
			}
		}
	}
}

template <unsigned int DIM> void MSP<DIM>::reducedGraph(){
	m_graph.clear();
	m_nodes.clear();
	m_cost.clear();
	m_start_index=-1;
	m_end_index=-1;
	try {
		m_current_forbidden=m_misleading.at(m_current_coord);
	}catch (const std::out_of_range& oor) {
		m_current_forbidden=std::set<State<DIM>>();
	}
	add_node_to_reduced_vertices(m_tree->getRoot(),m_tree->getRootState(),0.5);

	int l=m_nodes.size();

	for(int i=0;i<l;++i){
		m_graph.add_vertex(i,m_lambda2*(m_nodes[i].first-m_end_coord).norm());
		if(is_start(m_nodes[i])){
			if(m_start_index!=-1){
				std::cout << "2 start nodes, fail" << std::endl;
				return;
				//exit(1);
			}
			m_start_index=i;
		}
		if(is_goal(m_nodes[i])){
			if(m_end_index!=-1){
				std::cout << "2 end nodes, fail" << std::endl;
				return;
				//exit(1);
			}
			m_end_index=i;
		}
	}
	for(int i=0;i<l;++i){
		for(int j=i+1;j<l;++j){
			if(neighboor(m_nodes[i],m_nodes[j])){
				m_graph.add_edge(i,j,m_cost[j]);
				m_graph.add_edge(j,i,m_cost[i]);
			}
		}
	}
	if(m_start_index==-1){
		std::cout << "0 start node, fail" << std::endl;
		return;
	}
	if(m_end_index==-1){
		std::cout << "0 end node, fail" << std::endl;
		return;
	}
}

template <unsigned int DIM> bool MSP<DIM>::is_in(State<DIM> pt,std::pair<State<DIM>,double> node){
	if((pt-node.first).abs().isWithin((*(m_tree->getDirections()))[0]*(2*node.second)))
		return true;
	return false;
}

template <unsigned int DIM> double MSP<DIM>::cost(Node<DIM>* n){
	if (!isEpsilonObstacle(n)){
		return (m_lambda1*n->getValue()+m_lambda2)*m_tree->getVolume(n->getDepth());
	}else{
		return m_M;
	}
}

template <unsigned int DIM> bool MSP<DIM>::neighboor(std::pair<State<DIM>,double> &na,std::pair<State<DIM>,double> &nb){
	double l=2*(na.second+nb.second);
	State<DIM> diff=(na.first-nb.first).abs()-(*(m_tree->getDirections()))[0]*l;
	diff.sort();
	if(fabs(diff[DIM-1])==0 && fabs(diff[DIM-1]-diff[DIM-2])!=0)
		return true;
	return false;
}


template <unsigned int DIM> std::deque<State<DIM>> MSP<DIM>::getSmoothedPath(){
	std::deque<State<DIM>> sPath;
	sPath.push_back(m_current_path[0]);
	State<DIM> cur=m_current_path[0];
	int i=2;
	float dinc=(*(m_tree->getDirections()))[0].min()*m_tree->getScale(m_tree->getMaxDepth())*0.00999;
	while(i<m_current_path.size()){
		State<DIM> cur2=m_current_path[i];
		State<DIM> inc=(cur2-cur)*(dinc/(cur2-cur).norm());
		float jmax= floor((cur2-cur).norm()/dinc);
		bool safe=true;
		for(float j=1.0f;j<jmax;j=j+1.0f){
			if(isEpsilonObstacle(m_tree->getNode(cur+inc*j))){
				safe=false;
				break;
			}
		}
		if(!safe){
			cur=m_current_path[i-1];
			sPath.push_back(cur);
		}
		i++;
	}
	sPath.push_back(m_current_path[m_current_path.size()-1]);
	return sPath;
}

template <unsigned int DIM> void MSP<DIM>::iterationDetails(kshortestpaths::BasePath* result){
	bool console=false;
	if(console){
		std::cout << std::endl << std::endl << "Iteration " << m_nb_step << std::endl
				<< "nkipi: " << m_current_coord << " with scale factor " << m_current_scale << std::endl;
		std::cout<< "rejects : ";
		for(auto& c : m_current_forbidden)
			std::cout << c << " , ";
		std::cout << std::endl;
		std::cout << "Gi:" <<std::endl;
		for(int i=0;i<m_nodes.size();++i){
			std::cout << "Vertex " << i << " at " << m_nodes[i].first << " with scale " << ((int)16*m_nodes[i].second) << " and cost " << m_cost[i] << ", neighbor with ";
			for(int j=i+1;j<m_nodes.size();++j){
				if(neighboor(m_nodes[i],m_nodes[j])){
					std::cout << j << " , ";
				}
			}
			std::cout << std::endl;
		}
	}
	bool latex=false;
	if(latex && DIM==2){
		if(m_nb_step==0){
			//remove previous results
			system("exec rm -r /home/florian/workspace/HighDimMSP/results/iterationFiles/*");
		}
		std::stringstream ss;
		ss << "results/iterationFiles/iteration" << m_nb_step << ".tex";
		std::fstream file(ss.str(),std::fstream::out);
		file << "\\begin{tikzpicture}[scale=0.22]" << std::endl
				<< "\\tikzstyle{treenodes}=[black,thick,fill=white]" <<std::endl
				<< "\\tikzstyle{every node}=[circle,draw,minimum size=2pt,inner sep=1pt];" <<std::endl
				<< "\\node[rectangle,draw] at (0,17) {Iteration " << m_nb_step << "};" <<std::endl
				<< "\\draw[black,thick,fill=red] (-16,-16) rectangle (16,16);" <<std::endl;
		for(int i=0;i<m_nodes.size();++i){
			file << "\\draw[treenodes] "
					<< m_nodes[i].first-(*(m_tree->getDirections()))[0]*m_nodes[i].second*2
					<< " rectangle "
					<< m_nodes[i].first+(*(m_tree->getDirections()))[0]*m_nodes[i].second*2
					<< ";" << std::endl;
		}
		for(int i=0;i<m_nodes.size();++i){
			file << "\\node";
			if(i==m_start_index)
				file << "[green,thick]";
			if(i==m_end_index)
				file << "[red,thick]";
			file << " at " << m_nodes[i].first << " (" << i << ") {" << i << "};" << std::endl;
		}
		for(int i=0;i<m_nodes.size();++i){
			for(int j=i+1;j<m_nodes.size();++j){
				if(neighboor(m_nodes[i],m_nodes[j])){
					file << "\\path[draw] (" << i << ") -- (" << j << ");" << std::endl;
				}
			}
		}
		if(m_current_path.size()>1){
			file << "\\path[draw,thick] " << m_current_path.front();
			if(m_current_path.size()>2){
				for(typename std::deque<State<DIM>>::iterator it=m_current_path.begin()+1,end=m_current_path.end()-1;it!=end;++it){
					file << " -- " << *it ;
				}
			}
			file << "-- (" << m_start_index << ");" << std::endl;
		}
		if(result!=NULL){
			file << "\\path[draw,thick,orange] (" << m_start_index <<")";
			for(int i=1;i<result->length()-1;++i){
				file << " -- (" << result->GetVertex(i)->getID() << ")";
			}
			file << "-- (" << m_end_index << ");" << std::endl;
		}
		file << "\\end{tikzpicture}" << std::endl;
		file.close();
	}
}




#endif /* MSP_H_ */
